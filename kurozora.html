<!DOCTYPE html>
<html>
	<head>
		<title>Coca Cola! Espuma!</title>
        <!-- script src="https://unpkg.com/aframe"></script-->
        <!--script src="https://unpkg.com/aframe-text-sprite"></script-->
	</head>
	<body>
    <style>
        html, body, script {
            padding: 0;
            border: 0;
            margin: 0;
        }
    </style>

  <script type="module">

    // const shortenings for easier typing
    const f = false; const t = true;

    //import the good shtuff
    import * as THREE from './js/build/three.module.js';
    import { OBJLoader2 } from './js/examples/jsm/loaders/OBJLoader2.js'; 

    if (false) {
        console.log("The world has ended. Please do not run this program, and instead take shelter.");
    }

    // creates a world to hold all the data 
    const scene = new THREE.Scene();
    // camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const X_AXIS = new THREE.Vector3(1, 0, 0);
    const Y_AXIS = new THREE.Vector3(0, 1, 0);
    camera.position.y += 1;
    camera.position.z = 7;
    let cameraBuildupR = 0;
    let cameraBuildupL = 0;
    const CAMERATHRESHOLD = 20;

 
    // renderer
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight); // renderer is size of the entire window
    renderer.setClearColor(0x2E1C31, 1);
    document.body.appendChild(renderer.domElement);

    // variable definitions 
    let staticBodies = [];

    // keyboard input handler, takes inputs for arrow keys.
    let upKey = f; let downKey = f; let rightKey = f; let leftKey = f; let qKey = f; let eKey = f; // controls lol
    document.addEventListener('keydown', eventKeyDown);
    function eventKeyDown(in_key) {
        switch (in_key.code) {
            case "ArrowUp":
            case "KeyW":
                upKey = t;
                break;
            case "ArrowDown":
            case "KeyS":
                downKey = t;
                break;
            case "ArrowRight":
            case "KeyD":
                rightKey = t;
                break;
            case "ArrowLeft":
            case "KeyA":
                leftKey = t;
                break;
            case "KeyQ":
                qKey = t;
            case "KeyE":
                eKey = t;
        }
    }
    document.addEventListener('keyup', eventKeyUp);
    function eventKeyUp(in_key) {
        switch (in_key.code) {
            case "ArrowUp":
            case "KeyW":
                upKey = f;
                break;
            case "ArrowDown":
            case "KeyS":
                downKey = f;
                break;
            case "ArrowRight":
            case "KeyD":
                rightKey = f;
                break;
            case "ArrowLeft":
            case "KeyA":
                leftKey = f;
                break;
            case "KeyQ":
                qKey = f;
            case "KeyE":
                eKey = f;
        }
    }


    //bounding box obj
    class boundingBox {
        constructor(in_V2max, in_V2min) {
            this.max = in_V2max;
            this.min = in_V2min;
        }
        collides_x(in_bB) {
            let output = f;
            if (this.max.x > in_bB.min.x && this.min.x < in_bB.max.x) {
                output = t;
            }
            if (this.min.x < in_bB.max.x && this.max.x > in_bB.min.x) {
                output = t;
            }
            return output;
        }
        collides_y(in_bB) {
            let output = f;
            if (this.max.y > in_bB.min.y && this.min.y < in_bB.max.y) {
                output = t;
            }
            if (this.min.y < in_bB.max.y && this.max.y > in_bB.min.y) {
                output = t;
            }
            return output;
        }
        collides(in_bB) {
            return (this.collides_x(in_bB) && this.collides_y(in_bB));
        }
        move(in_V2) {
            this.max = this.max.add(in_V2);
            this.min = this.min.add(in_V2);
        }
        forcemove(in_V2) {
            this.max = in_V2;
            this.min.x = in_V2.x * -1;
            this.min.y = in_V2.y * -1;
        }
        nmove(in_V2) { 
            let moveV2 = new THREE.Vector2(-in_V2.x, -in_V2.y)
            this.move(moveV2)
        }
        will_collide(in_bB, in_V2) {
            in_bB.move(in_V2);
            if (this.collides(in_bB)) {
                in_bB.nmove(in_V2);
                return t;
            } else {
                in_bB.nmove(in_V2);
                return f;
            }
        }
    }

    // image to reference
    const brick_texture = "assets/brick_1024.png";
    const wood_texture = "assets/wood_1024.png"
    const grass_texture = "assets/grass_top.png";
    const grass_side_texture = "assets/grass_side.png";
    const dirt_texture = "assets/grass_bottom.png";
    const flesh_texture = "assets/floomie_side.png";
    const purple_texture = "assets/floomie_bottom.png";
    const red_texture = "assets/floomie_top.png";
    const bench_img = "assets/bench.png";
    const char1_img = "assets/character1.png"; //orange
    const char2_img = "assets/character2.png"; //green
    const lamp_img = "assets/lamppost.png";
    const shack_img = "assets/shack.png";
    const tree1_img = "assets/tree1.png";
    const tree2_img = "assets/tree2.png";
    const IMG = [
        "assets/brick_1024.png",
        "assets/wood_1024.png",
        "assets/grass_top.png",
        "assets/grass_side.png",
        "assets/grass_bottom.png",
        "assets/floomie_side.png",
        "assets/floomie_bottom.png",
        "assets/floomie_top.png",

    ]


    // define player
    const player_texture = new THREE.TextureLoader().load( "assets/floomie_side_face.png" );
    player_texture.wrapS = THREE.RepeatWrapping;
    player_texture.wrapT = THREE.RepeatWrapping;
    player_texture.repeat.set( 1, 1 );
    

    const playerSize = new THREE.Vector2(1,1)
    const playerGeometry = new THREE.BoxGeometry(playerSize.x, playerSize.y, 1);
    const playerMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
    playerMaterial.map = player_texture;
    const player = new THREE.Mesh(playerGeometry, playerMaterial);
    let playerBoundingBox = new boundingBox(new THREE.Vector2(player.position.x + 1/2 * playerSize.x, player.position.y + 1/2 * playerSize.y), new THREE.Vector2(player.position.x - 1/2 * playerSize.x, player.position.y - 1/2 * playerSize.y));
    scene.add(player);
    const G = 0.015; // acceleration due to gravity 
    const V0_Y = 0.2; // initial velocity when jumping
    const A_X = 0.02; // hz acceleration, when on a surface
    const A_X_air = 0.01; // hz acceleration, when in mid air
    const A_V_MAX = 0.2; // hz max velocity
    const MU_X = 0.01; // hz deceleration 

    //objloader
    const objLoader = new OBJLoader2();
    const objMaterial = new THREE.MeshPhongMaterial({color:0xffffff});
    const objTexture = new THREE.TextureLoader().load( "assets/wood_1024.png" );
    objLoader.load('assets/houseyhouse.obj', (obj) => {
        obj.rotation.y -= -1.9;
        obj.position.x -= 0.5;
        obj.position.z -= 3;
        obj.position.y -= 1;

        obj.traverse( function ( child ) {

        if ( child.isMesh ) child.material.map = objTexture; //thank you angus for this

        } );
        scene.add(obj);
    });

    /*const loader = new OBJLoader();
    let object;
    loader.load('assets/houseyhouse.obj',

        function ( object ) {
            object.traverse( function ( child ) {
                    if (child.isMesh) {
                        child.geometry.computeFaceNormals();
                        child.geometry.computeVertexNormals( true );
                        child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        //child.material.map = wood_texture;
                        console.log("obj loaded.");

                    }
                    object.material = new THREE.MeshPhongMaterial({ color: 0xffffff});
                    object.rotation.y -= 2.5;
                    console.log("printed object");
                    scene.add(object);

                })
            },

        function ( error ) { console.log(error)},
    
    
    );*/


    //
    class staticPlane {
        constructor(in_width, in_height, in_V3_position, in_texture) {
            this.Width = in_width;
            this.Height = in_height;
            this.Geometry = new THREE.PlaneBufferGeometry(this.Width, this.Height);
            this.Material = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                alphaTest: 0.5});
            this.Texture = new THREE.TextureLoader().load(in_texture);
            this.Texture.wrapS = THREE.RepeatWrapping;
            this.Texture.wrapT = THREE.RepeatWrapping;
            this.Texture.repeat.set(1, 1);
            this.Material.map = this.Texture;
            this.Body = new THREE.Mesh(this.Geometry, this.Material);
            this.Body.position.x += in_V3_position.x;
            this.Body.position.y += in_V3_position.y;
            this.Body.position.z += in_V3_position.z;
            scene.add(this.Body);
        }

    }

    class staticBox {
        constructor(in_V3_size, in_V3_position, in_texture) {
            this.Size = in_V3_size;
            this.Geometry = new THREE.BoxGeometry(this.Size.x, this.Size.y, this.Size.z);
            this.Material = new THREE.MeshPhongMaterial({ color: 0xffffff });
            this.Texture = new THREE.TextureLoader().load(in_texture);
            this.Texture.wrapS = THREE.RepeatWrapping;
            this.Texture.wrapT = THREE.RepeatWrapping;
            this.Texture.repeat.set( this.Size.x, this.Size.y );
            this.Material.map = this.Texture;
            this.Body = new THREE.Mesh(this.Geometry, this.Material);
            this.Body.position.x += in_V3_position.x;
            this.Body.position.y += in_V3_position.y;
            this.Body.position.z += in_V3_position.z;
            //console.log(in_V3_position);
            scene.add(this.Body);
        }
    }

    class platform extends staticBox { //only works for box geometry
        constructor(in_V3_size, in_V3_position, in_texture) {
            super(in_V3_size, in_V3_position, in_texture);
            this.BoundingBox = new boundingBox(new THREE.Vector2(this.Body.position.x + 1/2 * this.Size.x, this.Body.position.y + 1/2 * this.Size.y), new THREE.Vector2(this.Body.position.x - 1/2 * this.Size.x, this.Body.position.y - 1/2 * this.Size.y));
            staticBodies.push(this.BoundingBox);
        }
    }

    // things to draw in the world
    let staticBoxes = [new staticBox(new THREE.Vector3(10,6,7), new THREE.Vector3(-3, -4, -4.5), grass_texture),
                        new staticBox(new THREE.Vector3(10.5, 12.5, 5.5), new THREE.Vector3(-10, -4, -5), dirt_texture),
                        new staticBox(new THREE.Vector3(500, 50, 0.1), new THREE.Vector3(250, -27.5, -1), dirt_texture),
                        
                        ];

    let staticPlanes = [new staticPlane(2, 2, new THREE.Vector3(0,0,-1),  lamp_img),
                        
                        ];

    let platforms = [new platform(new THREE.Vector3(10,6,2), new THREE.Vector3(-20, -4, 0), grass_texture),
                    new platform(new THREE.Vector3(10,6,2), new THREE.Vector3(0, -4, 0), brick_texture),
                    new platform(new THREE.Vector3(5,6,2), new THREE.Vector3(10, -4, 0), brick_texture),
                    new platform(new THREE.Vector3(10,12,5), new THREE.Vector3(-10, -3, -5), grass_texture),
                    new platform(new THREE.Vector3(10,6,1.5), new THREE.Vector3(20, -4, 0), brick_texture),
                    new platform(new THREE.Vector3(10,6,1.5), new THREE.Vector3(35, -4, 0), brick_texture),
                    new platform(new THREE.Vector3(10,6,1.5), new THREE.Vector3(51.5, -4, 0), brick_texture),
                    new platform(new THREE.Vector3(10.1,6,0.25), new THREE.Vector3(69.5, -4, 0), brick_texture),
                    new platform(new THREE.Vector3(10,6,2), new THREE.Vector3(79.5, -4, 0), brick_texture),
                    new platform(new THREE.Vector3(5,6,2), new THREE.Vector3(84.5, -0.5, 0), brick_texture),
                    new platform(new THREE.Vector3(4,4,2), new THREE.Vector3(94.5, 3.5, 0), brick_texture),
                    new platform(new THREE.Vector3(4,4,2), new THREE.Vector3(104.5, 3.5, 0), brick_texture),
                    
                    
                    ];

    // define light
    let lights = [];
    const toplight = new THREE.PointLight( 0xffffff );
    toplight.position.set( 0, 50, -2 );
    scene.add(toplight);
    const sidelight = new THREE.PointLight( 0xffffff );
    toplight.position.set( 0, 30, 3);
    scene.add(sidelight);
    const ambientLight = new THREE.AmbientLight( 0xffffff ); // soft white light
    scene.add( ambientLight );
  
    let ds = new THREE.Vector2(0,0); // ds = delta of displacement
    let is_on_floor = f;



    const init = function() {


    }

    const animate = function () {
        requestAnimationFrame(animate);
        
        // gravity
        ds.y -= G;
        is_on_floor = f;
        for (let i = 0; i < staticBodies.length; i++) {
            if (staticBodies[i].will_collide(playerBoundingBox, ds)) {
                ds.y = 0;
                is_on_floor = t;
            }
        }

        //console.log(is_on_floor);

        // jump
        if (upKey && is_on_floor) {
                ds.y += V0_Y;
        }
            
        // hz movement
        if (leftKey && rightKey) {
            ds.x = ds.x;
        } else if (leftKey && ds.x > -A_V_MAX) {
            if (ds.y != 0) {
                ds.x -= A_X_air;
            } else {
                ds.x -= A_X;
            }
        } else if (rightKey && ds.x < A_V_MAX) {
            if (ds.y != 0) {
                ds.x += A_X_air;
            } else {
                ds.x += A_X;
            }
        } else if (ds.x < A_X && ds.x > - A_X) {
            ds.x = 0;
        } else if (ds.x > 0) {
            ds.x -= MU_X;
        } else if (ds.x < 0) {
            ds.x += MU_X;
        }
        for (let i = 0; i < staticBodies.length; i++) {
            if (staticBodies[i].will_collide(playerBoundingBox, new THREE.Vector2(ds.x, G))) {
                ds.x = 0;
            }
        }
        
        
        if (ds.x > 0) {
            if ((camera.position.x - player.position.x) < -1) { //left
                camera.position.x += ds.x;
            }
        } else if (ds.x < 0) {
            if ((camera.position.x - player.position.x) > 1) { //right
                camera.position.x += ds.x;
            }
        }

        //console.log(is_on_floor);
        //console.log(ds.y);

        /*
        if (Math.abs(ds.x) < A_V_MAX) {
            camera.rotation.y = ds.x / 2 * -1;
        }*/

        //allows the player to look down at their surroundings
        if (downKey) {

            if (camera.rotation.x > -0.25) camera.rotation.x -= 0.04;
        } else {
            if (camera.rotation.x < 0) camera.rotation.x += 0.015;
        }
        
        if (leftKey) {
            cameraBuildupL++;
            if(cameraBuildupL >= CAMERATHRESHOLD) if (camera.rotation.y < 0.2) camera.rotation.y += 0.02;
        } else {
            if (cameraBuildupL > 0) cameraBuildupL = 0;
            if (camera.rotation.y > 0) camera.rotation.y -= 0.02;
        }

        if (rightKey) {
            cameraBuildupR++;
            if (cameraBuildupR >= CAMERATHRESHOLD) if (camera.rotation.y > -0.2) camera.rotation.y -= 0.02;
        } else {
            if (cameraBuildupR > 0) cameraBuildupR = 0;
            if (camera.rotation.y < 0) camera.rotation.y += 0.02;
        }

        //console.log(camera.position);
        //console.log(player.position);

        if (player.position.y <= -15) {
            camera.position.x = 0;
            camera.position.y = 1;
            camera.position.z = 7;
            camera.rotation.x = 0;
            camera.rotation.y = 0;
            camera.rotation.z = 0;
            player.position.x = 0;
            player.position.y = 0;
            player.position.z = 0
            ds.x = 0;
            ds.y = 0;
            playerBoundingBox.forcemove(new THREE.Vector2(0.5, 0.5));
            is_on_floor = f;
            //location.reload();
        }
        
        camera.position.y += ds.y;   

        //console.log(camera.position.x - player.position.x); 
        camera.updateProjectionMatrix();
        moveObject(player, ds);
        playerBoundingBox.move(ds);
        renderer.render(scene, camera);
    };
    init();
    animate();

    function moveObject(o, in_V2) {
        o.position.x += in_V2.x;
        o.position.y += in_V2.y;
    }

    function rotateObject(o, in_V2) {
      o.rotation.x += in_V2.x;
      o.rotation.y += in_V2.y;
    }

  </script>
  </body>
  
  </html>